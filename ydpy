#!/usr/bin/python2.5

from __future__ import with_statement

from os.path import join as path_join
from locale import getpreferredencoding as get_system_encoding
from optparse import OptionParser
import sys


from libydp import YdpDict

def read_config():
	with open('/etc/ydpdict.conf') as file:
		return dict(line.strip().split(None, 1) for line in file)

config = read_config()

DICTIONARIES = \
(
	('e', 'en-pl', 'English-Polish', 100),
	('p', 'pl-en', 'Polish-English', 101),
	('g', 'de-pl', 'German-Polish',  200),
	('o', 'pl-de', 'Polish-German',  201),
)

oparser = OptionParser()
for short, long, text, value in DICTIONARIES:
	oparser.add_option('-%s' % short, '--%s' % long, action = 'store_const', const = value, dest = 'dict_n', help = 'use the %s dictionary' % text)
oparser.add_option('-f', '--path', action = 'store', dest = 'path', default = None)
oparser.set_defaults(dict_n = 100)
(options, args) = oparser.parse_args()

if args:
	import re
	matcher = re.compile(args[0], re.LOCALE | re.IGNORECASE | re.DOTALL).search
	del re
else:
	matcher = lambda s: True

path = options.path or config.get('Path')
if not path:
	raise ConfigurationError()
dict_n = options.dict_n

encoding = get_system_encoding()
if sys.stdout.isatty():
	from format_color import YdpFormatter
else:
	from format_text import YdpFormatter

formatter = None
try:
	with YdpDict(path_join(path, 'dict%03d.dat' % dict_n), path_join(path, 'dict%03d.idx' % dict_n)) as ydpd:
		for entry in ydpd:
			if not matcher(entry.name):
				continue
			formatter = YdpFormatter(encoding = encoding)
			formatter(entry.definition)
			sys.stdout.write(str(formatter))
finally:
	if formatter:
		print formatter.cleanup()

# vim:ts=4 sw=4 noet
