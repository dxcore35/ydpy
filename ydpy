#!/usr/bin/python2.5

from __future__ import with_statement

from ctypes import CDLL, Structure as CStructure
from ctypes import c_void_p, c_uint16, c_uint32, c_int, c_char, c_char_p
from ctypes import POINTER as c_pointer_t, pointer as c_pointer, cast
from os.path import join as path_join
from locale import getpreferredencoding as get_system_encoding
from xml.etree import cElementTree as ET

import transliterate

XHTML_NS = 'http://www.w3.org/1999/xhtml'

def read_config():
	with open('/etc/ydpdict.conf') as file:
		return dict(line.strip().split(None, 1) for line in file)

config = read_config()
liby = CDLL('libydpdict.so.1')
libc = CDLL('libc.so.6')

class CYdpDict(CStructure):
	_fields_ = \
	(
		('dat', c_void_p),
		('idx', c_void_p),
		('words', c_void_p),
		('word_count', c_uint16),
		('indices', c_void_p),
		('encoding', c_int),
		('xhtml_header', c_int),
		('xhtml_title', c_char_p),
		('xhtml_style', c_char_p),
		('xhtml_use_style', c_int)
	)

	def __init__(self, dat_file_name, idx_file_name):
		rv = liby.ydpdict_open(c_pointer(self), dat_file_name, idx_file_name, 1)
		if rv != 0:
			self._open = False
			raise IOError
		self._open = True

	def __enter__(self):
		return self
	
	def __exit__(self, *exc_info):
		self.close()

	def __iter__(self):
		return (self[i] for i in xrange(self.word_count))

	def __getitem__(self, nth):
		read_xhtml = liby.ydpdict_read_xhtml
		read_xhtml.restype = c_pointer_t(c_char)
		result = read_xhtml(c_pointer(self), c_uint32(nth))
		if result is None:
			raise IOError
		try:
			return ET.fromstring(cast(result, c_char_p).value).find('./{%(XHTML_NS)%s}html/{%(XHTML_NS)s}body' % globals())
		finally:
			libc.free(result)
			
	def close(self):
		if self._open:
			liby.ydpdict_close(c_pointer(self))

encoding = get_system_encoding()

for n in (100, 101, 200, 201):
	with CYdpDict(path_join(config['Path'], 'dict%03d.dat' % n), path_join(config['Path'], 'dict%03d.idx' % n)) as ydpd:
		for definition in ydpd:
			print definition

# vim:ts=4 sw=4 noet
